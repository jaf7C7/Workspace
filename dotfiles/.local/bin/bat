#!/bin/sh
#
# `bat`: Battery monitor
#
# Dependencies:
#	- `tmux` or `screen` or `notify-send` (optional)
# Environment:
#	- SCREENDIR, BAT_DIR, TMP_DIR
#
# Return values:
#   - 0 (No action required)
#   - 1 (Low battery)
#   - 2 (Battery charging while full)
#   - 3 (Status unknown)
#   - 4 (Other error)

: "${SCREENDIR:=/run/screen/S-joss}"
: "${BAT_DIR:=/sys/class/power_supply/BAT1}"
: "${TMP_DIR:="${TMPDIR:="${TMP:=/tmp}"}"}"

usage() {
	echo 'usage: bat [-q|-m|-k]'
} >&2

error() {
	printf '%s: ' "${0##*/}"
	printf '%s\n' "$@"
	exit 1
} >&2

check_status() {
	read -r capacity <"$BAT_DIR/capacity"
	read -r status <"$BAT_DIR/status"
	msg="$capacity%"

	case $status in
		Discharging)
			[ "$capacity" -lt 30 ] && return 1
		;;

		Charging)
			msg="~${msg}"
			[ "$capacity" -gt 70 ] && return 2
		;;

		*)
			return 3
		;;
	esac

	return 0
}

notify() {
	if [ -z "${TMUX}${STY}" ]; then
		if [ -n "$DISPLAY" ] && command -v notify-send >/dev/null 2>&1; then
			notify-send 'Battery Warning' "<b>$1</b>"
		fi

		return
	fi

	for session in $(tmux ls -F '#{session_id}' 2>/dev/null); do
		for client in $(tmux lsc -t "$session" -F '#{client_name}'); do
			tmux display -c "$client" "$1"
		done
	done

	for session in "$SCREENDIR"/*; do
		session="${session##*/}"

		case $(screen -lsS $session) in
			*Attached*) screen -S "$session" -X echo "$1"
		esac
	done
}

main() {
	log_file="$TMP_DIR/bat.log"

	quiet=0
	monitor=0
	kill=0

	while getopts :qmkh opt; do
		case $opt in
			q) quiet=1 ;;
			m) monitor=1 ;;
			k) kill=1 ;;
			h) usage ;;
			*) ! usage ;;
		esac
	done

	shift $((OPTIND - 1))

	if [ "$kill" -eq 1 ]; then
		if [ ! -e "$log_file" ]; then
			error 'unable to kill process: is bat running?'
		fi

		read -r pid <"$log_file"

		while printf 'Kill battery monitor (%s)? [y/N] ' "$pid"; read -r reply; do
			case $reply in
				y) break ;;
				n) return 1 ;;
				*) printf '%s\n' '?'; continue ;;
			esac
		done

		kill "$pid"

		rm "$log_file"
		return
	fi

	if [ "$monitor" -eq 1 ]; then
		if [ ! -e "$log_file" ]; then
			: >"$log_file"

			( bat -m & )

			return
		fi

		read -r pid <"$log_file"
		[ -n "$pid" ] && error 'already running'

		printf '%s %s\n' $$ >"$log_file"

		trap '[ -e "$log_file" ] && rm "$log_file"' EXIT

		while check_status; return=$?; do
			case $return in
				3) notify "Check battery: $msg" ;;
				2) notify "Battery full: $msg" ;;
				1) notify "Low battery: $msg" ;;
			esac

			sleep 30
		done

		return 4
	fi

	check_status
	return=$?

	[ "$quiet" -eq 1 ] || printf '%s\n' "$msg"

	return "$return"
}

main "$@"
