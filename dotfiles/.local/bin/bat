#!/bin/sh
# 
# `bat`: Battery monitor
# 
# Return values:
# - 0 (No action required)
# - 1 (Low battery)
# - 2 (Battery charging while full)
# - 3 (Status unknown)
# - 4 (Other error)
# 
# Dependencies:
# - POSIX utilities: `[` `command` `printf` `read` `rm` `sleep`
# - `tmux` (recommended) or `screen` or `notify-send`
# 
# Environment:
: "${SCREENDIR:=/run/screen/S-joss}"
: "${BAT_DIR:=/sys/class/power_supply/BAT1}"
: "${TMP_DIR:="${TMPDIR:="${TMP:=/tmp}"}"}"

usage() {
	printf '%s\n' 'usage: bat [-q|-m|-k]'
	exit
} >&2

check_status() {
	# Reading from the system files can be slow, and if you have a call
	# to bat in your shell prompt this can slow down the prompt quite a 
	# bit.
	# 
	# This can be remedied by reading instead from the log file created
	# by a running monitor process which is much faster. If no monitor
	# is running, then the system files are read anyway.
	if [ "$pid" = $$ ] || [ -z "$pid" ]; then
		read -r cap <"$BAT_DIR/capacity"
		read -r stat <"$BAT_DIR/status"
	fi

	msg="$cap%"

	case $stat in
		Discharging) [ "$cap" -lt 30 ] && return 1 ;;
		Charging)    msg="~${msg}" [ "$cap" -gt 70 ] && return 2 ;;
		*)           return 3 ;;
	esac

	return 0
}

print_status() {
	check_status
	rtn=$?

	# `silent` -> just return value no output.
	[ "$flag" = 'silent' ] && return "$rtn"

	# `quiet` -> only print message if non-zero return value.
	[ "$flag" = 'quiet' ] && [ "$rtn" -eq 0 ] || printf '%s\n' "$msg"

	return "$rtn"
}

monitor() {
	trap '
		[ -e "$log_file" ] && rm "$log_file"
		exit
	' INT TERM EXIT

	while {
		check_status
		return=$?
	} do
		printf '%s ' "$$" "$cap" "$stat" >"$log_file"

		case $return in
			3) notify "Check battery: $msg" ;;
			2) notify "Battery full: $msg" ;;
			1) notify "Low battery: $msg" ;;
		esac

		sleep 30
	done

	return 4
}

notify() {
	# If running in a graphical environment use `notify-send` to use
	# the desktop environment's own notification system.
	# 
	# Otherwise the PS1 prompt can be modified by adding:
	# 
	# 	__bat() {
	# 		b="$(bat -q)"
	# 		[ -n "$b" ] && printf '[%s]' "$b"
	# 		unset b
	# 	}
	#	PS1='$(__bat)'"${PS1}"
	# 	export PS1
	# 
	# to the shell's '.rc' file. Note the use of single quotes.
	# Or alternatively, if your shell has the PROMPT_COMMAND variable:
	# 
	# 	PROMPT_COMMAND='__bat'
	# 	export PROMPT_COMMAND
	# 
	if [ -n "$DISPLAY" ]; then
		command -v notify-send >/dev/null 2>&1 \
			&& notify-send 'Battery Warning' "<b>$1</b>"
		return
	fi

	# Loop over all sessions and all attached clients.
	for session in $(tmux ls -F '#{session_id}' 2>/dev/null); do
		for client in $(tmux lsc -t "$session" -F '#{client_name}'); do
			tmux display -c "$client" "$1"
		done
	done

	# Screen sessions are represented by sockets in the 'SCREENDIR'
	# directory, the names of which are the respective session
	# names.
	# 
	# When listing sessions it's easier to list sockets in
	# 'SCREENDIR' than to parse the output of `screen -ls`.
	for session in "$SCREENDIR"/*; do
		session="${session##*/}"

		case $(screen -lsS $session) in
			*Attached*) screen -S "$session" -X echo "$1"
		esac
	done
}

main() {
	log_file="$TMP_DIR/bat.log"

	[ -e "$log_file" ] && read -r pid cap stat <"$log_file"

	while getopts :qsmkh opt; do
		case $opt in
			q) flag='quiet' ;;
			s) flag='silent' ;;
			m) func='monitor' ;;
			h) usage ;;
			*) ! usage ;;
		esac
	done

	shift $((OPTIND - 1))

	case $func in
		monitor) monitor ;;
		*) print_status ;;
	esac
}

main "$@"

