#!/bin/sh
#
# `cmt`: Filter which toggles comments.
#
# Depends: none
# Environment: none

main ()
{
	case "$1" in
		-w)
			# E.g. 'cmt -w "foo"'
			# foo ... foo
			shift
			save_indent=1
			line_open="${1:-#} "
			line_close=" ${1:-#}"
		;;

		-b)
			# E.g. 'cmt -b "$(uni 1f603)"'
			# ðŸ˜ƒ 
			# ðŸ˜ƒ ...
			# ðŸ˜ƒ 
			shift
			save_indent=1
			block_open="${1:-#}"
			line_open="${1:-#} "
			block_close="${1:-#}"
		;;

		-c)
			# /* ... */
			line_open='/* '
			line_close=' */'
		;;

		-C)
			# /*
			#  * ...
			#  */
			save_indent=1
			block_open='/*'
			line_open=' * '
			block_close=' */'
		;;

		-h)
			# <!-- ... -->
			save_indent=1
			line_open='<!-- '
			line_close=' -->'
		;;

		-f)
			# Adds a trailing space.
			# E.g. 'cmt -f \!'
			# ! ...
			# ! ...
			# ! ...
			save_indent=1
			shift
			line_open="${1:-#} "
		;;

		*)
			# E.g. 'cmt //'
			# //...
			line_open="${1:-#}"
		;;
	esac

	while IFS= read -r line; do
		if [ ${i:=1} -eq 1 ]; then
			if [ -z "$line" ]; then
				printf '\n'
				continue
			fi

			i=$((i + 1))

			if [ -n "$save_indent" ]; then
				indent="${line%%[![:space:]]*}"
			fi

			if [ "${line#"$indent"}" = "$block_open" ]; then
				continue
			fi

			if [ -n "$block_open" ]; then
				printf '%s\n' "${indent}${block_open}"
			fi

			if [ -n "$block_close" ]; then
				trap 'printf "%s\n" "${indent}${block_close}"'\
					EXIT
			fi
		fi

		line="${line#"$indent"}"

		case "$line" in
			"")
				# Where formatting is important, comment empty
				# lines.
				if [ -n "$save_indent" ]; then
					line="$line_open"
				else
					printf '\n'
					continue
				fi
			;;

			"$block_close")
				trap - EXIT
				continue
			;;

			"$line_open"*"$line_close")
				line="${line#"$line_open"}"
				line="${line%"$line_close"}"
			;;

			*)
				line="${line_open}${line}${line_close}"
			;;
		esac

		printf '%s\n' "${indent}${line}"
	done
}

main "$@"

